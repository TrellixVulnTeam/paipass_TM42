"""
Django settings for backend project.

Generated by 'django-admin startproject' using Django 2.2.6.

For more information on this file, see
https://docs.djangoproject.com/en/2.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/2.2/ref/settings/
"""
import os
from collections import namedtuple
import socket
import logging
import sys
from urllib.parse import urlparse

sys.path.append('/code')
sys.path.append('/opt/project')

DEPLOYMENT_ENV_DEV = 'development'
DEPLOYMENT_ENV_PROD = 'production'
DEPLOYMENT_ENV_STAG = 'staging'

DEPLOYMENT_ENV = os.environ['DEPLOYMENT_ENVIRONMENT']


def is_in_cloud(deployment_env):
    if deployment_env == DEPLOYMENT_ENV_PROD:
        return True
    elif deployment_env == DEPLOYMENT_ENV_STAG:
        return True
    elif deployment_env == DEPLOYMENT_ENV_DEV:
        return False
    else:
        raise Exception(f"DEPLOYMENT_ENV: {DEPLOYMENT_ENV} NOT RECOGNIZED.")




# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

get_port = lambda port: ':' + str(port) if port != 80 else ''

SCHEME = os.environ['SCHEME']
FRONTEND_PORT = get_port(int(os.environ['FRONTEND_PORT']))
FRONTEND_DOMAIN = SCHEME + os.environ['FRONTEND_HOST'] + FRONTEND_PORT + '/'
ADMIN_PORT = get_port(int(os.environ['ADMIN_PORT']))
ADMIN_DOMAIN = SCHEME + os.environ['ADMIN_HOST'] + ADMIN_PORT + '/'
BACKEND_PORT = get_port(int(os.environ['BACKEND_PORT']))
BACKEND_DOMAIN = SCHEME + os.environ['BACKEND_HOST'] + BACKEND_PORT + '/'
PAIFORUM_PORT = get_port(int(os.environ['PAIFORUM_PORT']))
BASE_URL_PAIFORUM = SCHEME + os.environ['PAIFORUM_HOST'] + PAIFORUM_PORT + '/'

CATENA_PORT = get_port(int(os.environ['CATENA_PORT']))
BASE_URL_CATENA = SCHEME + os.environ['CATENA_HOST'] + CATENA_PORT + '/'

if is_in_cloud(DEPLOYMENT_ENV.lower()):

    DEBUG = False
    # A tuple representing a HTTP header/value combination that signifies 
    # a request is secure. This controls the behavior of the request 
    # object’s is_secure() method.
    # 
    # By default, is_secure() determines if a request is secure by 
    # confirming that a requested URL uses https://. This method is 
    # important for Django’s CSRF protection, and it may be used by 
    # your own code or third-party apps.
    #
    # If your Django app is behind a proxy, though, the proxy may be 
    # “swallowing” whether the original request uses HTTPS or not. 
    # If there is a non-HTTPS connection between the proxy and Django 
    # then is_secure() would always return False – even for requests 
    # that were made via HTTPS by the end user. In contrast, if there 
    # is an HTTPS connection between the proxy and Django then is_secure() 
    # would always return True – even for requests that were made originally 
    # via HTTP.
    SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
    # The domain to use for session cookies. Set this to a string such as 
    # "example.com" for cross-domain cookies, or use None for a standard domain 
    # cookie. 
    # 
    # Be cautious when updating this setting on a production site. If you update 
    # this setting to enable cross-domain cookies on a site that previously used 
    # standard domain cookies, existing user cookies will be set to the old domain. 
    # This may result in them being unable to log in as long as these cookies persist.
    SESSION_COOKIE_DOMAIN = '.' + os.environ['FRONTEND_HOST'] + FRONTEND_PORT
    # The domain to be used when setting the CSRF cookie. This can be 
    # useful for easily allowing cross-subdomain requests to be 
    # excluded from the normal cross site request forgery protection. 
    # It should be set to a string such as "example.com" to allow a 
    # POST request from a form on one subdomain to be accepted by a
    # view served from another subdomain.
    CSRF_COOKIE_DOMAIN = '.' + os.environ['FRONTEND_HOST'] + FRONTEND_PORT
    # Whether to use HttpOnly flag on the CSRF cookie. If this is set to True, 
    # client-side JavaScript will not be able to access the CSRF cookie.
    #
    # Designating the CSRF cookie as HttpOnly doesn't offer any practical
    # protection because CSRF is only to protect against cross-domain attacks. 
    # If an attacker can read the cookie via JavaScript, they’re already on the 
    # same domain as far as the browser knows, so they can do anything they like 
    # anyway. (XSS is a much bigger hole than CSRF.)
    CSRF_COOKIE_HTTPONLY = False
    # Whether to use HttpOnly flag on the language cookie. If this is set to True, 
    # client-side JavaScript will not be able to access the language cookie.
    SESSION_COOKIE_HTTPONLY = False
    # Whether to use a secure cookie for the CSRF cookie. If this is set to True,
    # the cookie will be marked as “secure”, which means browsers may ensure that 
    # the cookie is only sent with an HTTPS connection.
    CSRF_COOKIE_SECURE = True
    CSRF_COOKIE_SAMESITE = None
    SESSION_COOKIE_SAMESITE = None
    # Whether to use a secure cookie for the session cookie. If this is set to True, 
    # the cookie will be marked as “secure”, which means browsers may ensure that 
    # the cookie is only sent under an HTTPS connection.
    #
    # Leaving this setting off isn’t a good idea because an attacker could capture 
    # an unencrypted session cookie with a packet sniffer and use the cookie to 
    # hijack the user’s session.
    SESSION_COOKIE_SECURE = True

else:
    DEBUG = True
    # SESSION_COOKIE_DOMAIN = os.environ['FRONTEND_HOST']
    # SESSION_COOKIE_NAME = FRONTEND_PORT

# if DEPLOYMENT_ENV.upper() == DEPLOYMENT_ENV_STAG.upper():
#     DEBUG = True

if DEBUG:
    logging.getLogger().setLevel(logging.DEBUG)
    requests_log = logging.getLogger("requests.packages.urllib3")
    requests_log.setLevel(logging.DEBUG)
    requests_log.propagate = True


AWS_REGION_NAME = os.environ['REGION_NAME']
AWS_STORAGE_BUCKET_NAME = os.environ['AWS_STORAGE_BUCKET_NAME']
AWS_S3_CUSTOM_DOMAIN = '%s.s3.amazonaws.com' % AWS_STORAGE_BUCKET_NAME

STATICFILES_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'
STATIC_URL = "https://%s/%s/" % (AWS_S3_CUSTOM_DOMAIN, 'media')
DEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'

NEW_INFO_HASH = os.environ['NEW_INFO_HASH_DELIM']
USER_DECLINED_PUB_KEY_ADDR = 'USER_DECLINED_PUB_KEY_ADDR'
NULL_UUID = '99999999-9999-9999-9999-999999999999'
NULL_TXID = '00000000000000000000000000000000'
NULL_REF = '0' * 14

SECRET_KEY = os.environ['PAIPASS_DJANGO_SECRET']

# Constants that the original java code had.
PAIPASS_UUID = '00000000-0000-0000-0000-000000000000'
PAIPASS_NAMESPACE = 'PAIPASS'

PAIFORUM_UUID = os.environ['PAIFORUM_APP_UUID']
PAIFORUM_CLIENT_ID = os.environ['PAIFORUM_APP_CLIENT_ID']
PAIFORUM_APP_CLIENT_SECRET = os.environ['PAIFORUM_APP_CLIENT_SECRET']

CATENA_UUID = os.environ['CATENA_APP_UUID']
CATENA_CLIENT_ID = os.environ['CATENA_APP_CLIENT_ID']
CATENA_APP_CLIENT_SECRET = os.environ['CATENA_APP_CLIENT_SECRET']

# Info for the torrent client
TORRENT_HOST = os.environ['TORRENT_HOST']
TORRENT_PORT = os.environ['TORRENT_PORT']
TORRENT_URL = "http://%s:%s/" % (TORRENT_HOST, TORRENT_PORT)

BLOCKCHAIN_NET = os.environ['BLOCKCHAIN_NET']

CRYPTO_USER = os.environ['CRYPTO_USER']
CRYPTO_PASS = os.environ['CRYPTO_PASS']
CRYPTO_HOST = os.environ['CRYPTO_HOST']
CRYPTO_PORT = os.environ['CRYPTO_PORT']

BLOCKCHAIN_TYPE = os.environ['BLOCKCHAIN_TYPE']

CONFIRMATION_THRESHOLD = 6

CRYPTO_URL = r'http://%s:%s@%s:%s/' % (CRYPTO_USER,
                                       CRYPTO_PASS,
                                       CRYPTO_HOST,
                                       CRYPTO_PORT)

# Should be moved to core; experimenting with it here though.
PaicoinAuth = namedtuple('PaicoinAuth', ('username', 'password'))
PaicoinConfig = namedtuple('PaicoinConfig', ('url', 'auth', 'is_testnet',
                                             'blockchain_type'))

PAICOIN_AUTH = PaicoinAuth(username=CRYPTO_USER,
                           password=CRYPTO_PASS)
PAICOIN_CFG = PaicoinConfig(url=f'http://{CRYPTO_HOST}:{CRYPTO_PORT}',
                            auth=PAICOIN_AUTH,
                            is_testnet=False,  # BLOCKCHAIN_NET.lower() == 'testnet',
                            blockchain_type='paicoin')  # BLOCKCHAIN_TYPE)

PASSWORD_HASHERS = [
    'django.contrib.auth.hashers.BCryptSHA256PasswordHasher',
    'django.contrib.auth.hashers.BCryptPasswordHasher',
    'django.contrib.auth.hashers.PBKDF2PasswordHasher',
    'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',
]

# Application definition
DJANGO_CORE_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.sites',
]

THIRD_PARTY_APPS = [
    # django rest framework
    'rest_framework',
    'rest_framework.authtoken',
    # django-rest-auth
    'rest_auth',
    'rest_auth.registration',
    # For allauth library
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    # The following line is not a third-party app, however, for the purposes
    # of migrations occurring in the correct order, our local oauth2 app
    # needs to come before oauth2_provider. Getting to the point where this
    # was figured out was a nightmare, so be incredibly cautious if you decide
    # to move any OAuth2 machinery.
    'oauth2.apps.Oauth2Config',
    # django-oauth-toolkit
    'oauth2_provider',
    # django-cors-headers
    'corsheaders',
    'storages',
    'simple_sso.sso_server',
    'health_check',
    'channels',
]

LOCAL_APPS = [
    'users.apps.UsersConfig',
    'api.apps.ApiConfig',
    'identity_verification.apps.IdentityVerificationConfig',
    'pdp2.apps.Pdp2Config',
    'attributes.apps.AttributesConfig',
    'sso.apps.SsoConfig',
    'yggdrasil.apps.YggdrasilConfig',
    'pai_messages.apps.PaiMessagesConfig',
]

INSTALLED_APPS = DJANGO_CORE_APPS + THIRD_PARTY_APPS + LOCAL_APPS

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    # 'api.csrf.CsrfViewMiddleware',
    'oauth2_provider.middleware.OAuth2TokenMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

CORS_ALLOW_CREDENTIALS = True
CORS_ORIGIN_WHITELIST = (
    # "http://localhost",
    # Remove that path suffix from the url
    # e.g. 'https://api.staging-paipass.p19dev.com/' would reduce to:
    # https://api.staging-paipass.p19dev.com
    '/'.join(FRONTEND_DOMAIN.split('/')[:3]),
    '/'.join(ADMIN_DOMAIN.split('/')[:3]),
    # TODO: Why?
    '/'.join(BACKEND_DOMAIN.split('/')[:3]),
    SCHEME + 'p19dev.com',
    SCHEME + 'paicoin',
    SCHEME + f'backend.{DEPLOYMENT_ENV.lower()}.local',
    'http://' + f'backend.{DEPLOYMENT_ENV.lower()}.local',
    SCHEME + 'catenaart.com',

)

if DEPLOYMENT_ENV == DEPLOYMENT_ENV_PROD or DEPLOYMENT_ENV == DEPLOYMENT_ENV_STAG:

    ALLOWED_HOSTS = [dom.split(SCHEME)[-1] for dom in CORS_ORIGIN_WHITELIST]
    ALLOWED_HOSTS.append('10.0.0.169')
    ALLOWED_HOSTS.extend(['10.0.1.%d' % i for i in range(256)])
    ALLOWED_HOSTS.extend(['10.0.3.%d' % i for i in range(256)])
    # This will resolve to something like:
    # ip-10-0-1-219.us-east-2.compute.internal
    # This is needed because when paicoin (um no, it isn't paicoin;
    # but something internal is trying to reach this instance
    # as indicated by the logs)
    #  tries to send something to:
    #  f'backend.{DEPLOYMENT_ENV.lower()}.local'
    # it will end up instead as:
    #  ip-10-0-1-219.us-east-2.compute.internal
    # and django will complain that it is an invalid host and
    # thus block the request.
    ALLOWED_HOSTS.append(socket.gethostname())
    # paicoin instance can't reach backend if this is not here.
    ALLOWED_HOSTS.append('backend')
    # for paicoin
    ALLOWED_HOSTS.append(f'backend.{DEPLOYMENT_ENV.lower()}.local')
    CSRF_TRUSTED_ORIGINS = ALLOWED_HOSTS + list(('.p19dev.com',))


elif DEPLOYMENT_ENV == DEPLOYMENT_ENV_DEV:
    ALLOWED_HOSTS = [FRONTEND_DOMAIN,
                     ADMIN_DOMAIN,
                     'localhost',
                     # This is so that the torrent client can reach it.
                     'backend']

else:
    raise Exception(f"DEPLOYMENT_ENV: {DEPLOYMENT_ENV} NOT RECOGNIZED.")

CSRF_TRUSTED_ORIGINS = ALLOWED_HOSTS
CSRF_TRUSTED_ORIGINS.append(urlparse(BASE_URL_CATENA).netloc)
SITE_ID = 1
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

ROOT_URLCONF = 'backend.urls'
LOGIN_URL = FRONTEND_DOMAIN + 'login'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'api', 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'django.template.context_processors.request',
            ],
        },
    },
]

WSGI_APPLICATION = 'backend.wsgi.application'

AUTHENTICATION_BACKENDS = (
    # Needed to login by username in Django admin, regardless of `allauth`
    'django.contrib.auth.backends.ModelBackend',

    # `allauth` specific authentication methods, such as login by e-mail
    'allauth.account.auth_backends.AuthenticationBackend',
)

# AllAuth Settings
ACCOUNT_AUTHENTICATION_METHOD = 'email'
ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_USERNAME_REQUIRED = False
ACCOUNT_USER_MODEL_USERNAME_FIELD = None
ACCOUNT_ADAPTER = 'api.adapters.AccountAdapter'
EMAIL_VERIF_URL = '/email-verification/{0}'

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework.authentication.SessionAuthentication',
        # 'api.authentication.SessionAuthentication',
        'rest_framework.authentication.TokenAuthentication',
        'oauth2_provider.contrib.rest_framework.OAuth2Authentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ),
}

# for django-rest-auth
REST_AUTH_SERIALIZERS = {
    'LOGIN_SERIALIZER': 'api.serializers.LoginSerializer',
}

REST_AUTH_REGISTER_SERIALIZERS = {
    # TODO Probably need login serializer as well.
    'REGISTER_SERIALIZER': 'api.serializers.RegisterSerializer',
}

prefix = 'This permission gives the requestor the ability to see '
OAUTH2_PROVIDER = {
    # this is the list of available scopes
    'SCOPES': {'read': 'Read scope',
               'write': 'Write scope',
               'groups': 'Access to your groups',
               'READ_ALL.PAIPASS.EMAIL': prefix + 'your email.',
               'READ_ALL.PAIPASS.PHONE': prefix + 'your phone.',
               'READ_ALL.PAIPASS.NAME': prefix + 'your name.',
               },
    'OAUTH2_VALIDATOR_CLASS': 'oauth2.validators_redux.OAuth2Validator',
    'SCOPES_BACKEND_CLASS': 'oauth2.scopes.ScopesValidation',
}

OAUTH2_PROVIDER_APPLICATION_MODEL = 'oauth2.PaipassApplication'
OAUTH2_PROVIDER_ACCESS_TOKEN_MODEL = 'oauth2.PaipassAccessToken'
OAUTH2_PROVIDER_GRANT_MODEL = 'oauth2.PaipassGrant'
OAUTH2_PROVIDER_REFRESH_TOKEN_MODEL = 'oauth2.PaipassRefreshToken'

SSO_SECRET_DISCOURSE = os.environ['SSO_SECRET_DISCOURSE']

# Database
# https://docs.djangoproject.com/en/2.2/ref/settings/#databases
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.environ['PAIPASS_DB_NAME'],
        'USER': os.environ['SQL_USER'],
        'PASSWORD': os.environ['SQL_PASS'],
        'HOST': os.environ['SQL_HOST'],
        'PORT': os.environ['SQL_PORT']
    }
}

AUTH_USER_MODEL = 'users.PaipassUser'

# Password validation
# https://docs.djangoproject.com/en/2.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

DATA_ROOT = os.path.expanduser(os.getenv('DATA_ROOT', '/'))
MEDIA_ROOT = DATA_ROOT + DEPLOYMENT_ENV


def ensure_dirpath_existence(paths):
    for path in paths:
        if MEDIA_ROOT not in path and BASE_DIR not in path:
            path = os.path.join(MEDIA_ROOT, path)

        if os.path.isfile(path):
            dirpath = os.path.dirname(path)

        else:
            dirpath = path

        if not os.path.exists(dirpath):
            os.makedirs(dirpath)


TORRENT_DIR = os.path.join(MEDIA_ROOT, 'torrent')
BITTORRENT_TORRENT_FILE_DIR = os.path.join(TORRENT_DIR, 'torrent_file')
BITTORRENT_TORRENT_DATA_DIR = os.path.join(TORRENT_DIR, 'torrent_data/')
AGGREGATED_DATA_DIR = os.path.join(MEDIA_ROOT, 'aggregated_data')

FILE_UPLOAD_HANDLERS = ["yggdrasil.upload_handler.UploadProgressHandler",
                        # "django.core.files.uploadhandler.MemoryFileUploadHandler",
                        # "django.core.files.uploadhandler.TemporaryFileUploadHandler"
                        "yggdrasil.upload_handler.MemoryFileUploadHandler",
                        "yggdrasil.upload_handler.TemporaryFileWithTrackedProgressUploadHandler"]

CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
        'LOCATION': 'django_cache',
    }
}

ASGI_APPLICATION = "backend.asgi.application"

DEFAULT_CHANNEL_CACHE_HOST = f"redis://:{os.environ['CACHE_PASS']}@{os.environ['CACHE_HOST']}:{os.environ['CACHE_PORT']}"
CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            "hosts": [DEFAULT_CHANNEL_CACHE_HOST],
        },
    },
}

LOG_FILE_PATH = os.path.join(BASE_DIR, 'logs', 'logs.txt')

ensured_paths = (BITTORRENT_TORRENT_DATA_DIR,
                 BITTORRENT_TORRENT_FILE_DIR,
                 AGGREGATED_DATA_DIR,
                 os.path.dirname(LOG_FILE_PATH))
ensure_dirpath_existence(ensured_paths)

LOGGER = logging.getLogger(__name__)
LOGGER.setLevel(logging.DEBUG)

fh = logging.FileHandler(LOG_FILE_PATH)
fh.setLevel(logging.DEBUG)

logFormatter = logging.Formatter("%(asctime)s [%(levelname)-5.5s]  %(message)s")
fh.setFormatter(logFormatter)

LOGGER.addHandler(fh)

stdout_handler = logging.StreamHandler(sys.stdout)
stdout_handler.setLevel(logging.DEBUG)
stdout_handler.setFormatter(logFormatter)
LOGGER.addHandler(stdout_handler)

# Internationalization
# https://docs.djangoproject.com/en/2.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_L10N = True

USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/2.2/howto/static-files/

STATIC_URL = '/static/'

CONFINEMENT = os.environ.get('CONFINEMENT', 'WIDE_OPEN').upper()
ACCOUNTS_EMAIL = os.environ['ACCOUNTS_EMAIL']

if CONFINEMENT == 'LOCAL_ONLY':
    import localstack_client.session

    localstack_host = 'localstack'
    localstack_port = '4566'
    localstack_proto = 'https' if is_in_cloud(DEPLOYMENT_ENV) else 'http'
    AWS_API = localstack_client.session.Session(localstack_host=localstack_host)
    # localstack now uses one port for everything
    # need to patch in those ports
    AWS_API._service_endpoint_mapping.update({'ses': f'{localstack_proto}://{localstack_host}:{localstack_port}',
                                              'sns': f'{localstack_proto}://{localstack_host}:{localstack_port}',
                                              's3': f'{localstack_proto}://{localstack_host}:{localstack_port}'})
    ses = AWS_API.client('ses')
    response = ses.verify_email_identity(
        EmailAddress=ACCOUNTS_EMAIL
    )

    s3_client = AWS_API.client('s3')
    s3_client.create_bucket(Bucket=os.environ['AWS_STORAGE_BUCKET_NAME'])

elif CONFINEMENT == 'WIDE_OPEN':
    import boto3 as AWS_API
else:
    raise Exception(f'CONFINEMENT ${CONFINEMENT} not recognized')